## Private 메소드 테스트하는 방법
* Java Reflection을 사용하여 원하는 메소드를 가져옵니다.
* setAccessible 메서드로 해당 메서드에 접근을 허용합니다.
* invoke 메서드를 통해 메서드를 실행시켜 테스트를 진행할 수 있습니다.

## 통합 테스트
### 장점
* 모든 Bean을 올리고 테스트를 진행하기 때문에 운영 환경과 가장 유사하게 테스트 가능합니다.
* 컨트롤러 테스트를 주로 하며 요청부터 응답까지 전체 플로우를 테스트합니다.


### 단점
* 모든 Bean을 올리고 테스트를 진행하기 때문에 테스트 시간이 오래 걸립니다.

## 서비스 테스트
### 장점
* 진행하고자 하는 테스트에만 집중할 수 있습니다.
* 테스트 진행 시 중요 관점이 아닌 것들은 Mocking 처리해서 외부 의존성을 줄일 수 있습니다.
* 테스트 속도가 빠릅니다.

### 단점
* 의존성 있는 객체를 Mocking하기 때문에 서비스 테스트만으로 완결된 테스트는 아니며, 꼭 통합 테스트도 진행해야 합니다.

## Repository 테스트
### 장점
* Repository 관련된 Bean들만 등록하기 떄문에 통합 테스트에 비해서 빠릅니다.
* Repository에 대한 관심사만 테스트할 수 있습니다.
* JpaRepository에서 기본적으로 제공해주는 findById, findByAll 등은 테스트 하지 않습니다.
* 주로 커스텀하게 작성한 쿼리들을 테스트합니다.

### 단점
* 테스트 범위가 작기 때문에 실제 환경과 차이가 발생합니다.

## POJO 테스트
### 장점
* Entity, 일반 POJO 등의 객체를 테스트합니다.
* 외부에서 주입 받을 의존성도 없고 Mocking할 대상도 없습니다.

### 단점
* 없음

## Mockito
### 서비스 테스트 시
* @InjectMocks로 테스트할 클래스를 주입받습니다.
* Mocking할 클래스들은 @Mock, @Spy로 Mocking 합니다.

### 통합 테스트 시
* @Autowired로 테스트할 클래스를 주입받습니다.
* Mocking할 클래스들은 @MockBean, @SpyBean으로 Mocking 합니다.

### Mock
* 껍데기만 있는 객체이며 내부 구현은 모두 사용자에게 위임합니다.

### Spy
* 사용자에게 위임한 코드 위에는 전부 실제 객체의 것을 사용합니다.

### 외부 API 테스트
* 메소드에서 사용하는 RestTemplate만 @RestClientTest로 MockRestServiceServer를 사용하여 단위 테스트
* 위의 단위 테스트를 믿고, 해당 메소드에서 RestTemplate를 사용하는 부분은 Mocking 후, 메소드 단위 테스트

## 테스트하면서 어려웠던 점
* 전체 통합테스트를 진행했었는데 너무 느려서 비효율적이었음.
  * 그래서 Mockito를 사용하여 서비스 및 POJO 테스트는 단위 테스트로 진행
* private 메소드 테스트 시 당황함
  * Java 리플렉션 사용하여 테스트 진행
* 입력 데이터가 많아져서 통합 테스트 시 입력값 setup이 힘들었음
  * objectMapper를 사용하여 JSON 문자열을 객체로 변환하여 테스트

