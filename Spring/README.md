## 트랜잭션 전파 속성
진행되고 있는 트랜잭션에서 다른 트랜잭션이 호출될 때 어떻게 처리할지 정하는 것입니다.

### 전파 설정 옵션
\@Transactional의 옵션 propagation을 통해 설정할 수 있습니다.
* REQUIRED(기본값)
  * 부모 트랜잭션이 존재한다면 부모 트랜잭션으로 합류합니다.
  * 부모 트랜잭션이 없다면 새로운 트랜잭션을 생성합니다.
  * 중간에 롤백이 발생한다면 모두 하나의 트랜잭션이기 때문에 진행사항이 모두 롤백됩니다.
* REQUIRES_NEW
  * 무조건 새로운 트랜잭션을 생성합니다.
  * 각각의 트랜잭션이 롤백되더라도 서로 영향을 주지 않습니다.
* MANDATORY
  * 부모 트랜잭션에 합류합니다.
  * 만약 부모 트랜잭션이 없다면 예외를 발생시킵니다.
* NESTED
  * 부모 트랜잭션이 존재한다면 중첩 트랜잭션을 생성합니다.
  * 중첩된 트랜잭션 내부에서 롤백 발생시 해당 중첩 트랜잭션의 시작 지점까지만 롤백됩니다.
  * 중첩 트랜잭션은 부모 트랜잭션이 커밋될 때 같이 커밋됩니다.
  * 부모 트랜잭션이 존재하지 않는다면 새로운 트랜잭션을 생성합니다.
  * 중첩 트랜잭션이 끝난 후 부모 트랜잭션에서 롤백이 발생하면 모든 트랜잭션을 롤백합니다.
* NEVER
  * 트랜잭션을 생성하지 않습니다.
  * 부모 트랜잭션이 존재한다면 예외를 발생시킵니다.
  * 부모 트랜잭션이 없다면 트랜잭션을 생성하지 않고 기능을 진행합니다.
* SUPPORTS
  * 부모 트랜잭션이 있다면 합류합니다.
  * 진행중인 부모 트랜잭션이 없다면 트랜잭션을 생성하지 않습니다.
* NOT_SUPPORTED
  * 부모 트랜잭션이 있다면 보류시킵니다.
  * 진행중인 부모 트랜잭션이 없다면 트랜잭션을 생성하지 않습니다.

## 트랜잭션 격리 수준
* 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준

### READ_UNCOMMITED (커밋되지 않는 읽기, level 0)
* 아직 commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용합니다.
* Dirty Read 발생

### READ_COMMITED (커밋된 읽기, level 1)
* 트랜잭션이 commit 되어 확정된 데이터만을 읽도록 허용
* 커밋되기 전과 후의 select 결과가 다를 수 있습니다.

### REPEATABLE_READ (반복 가능한 읽기, level 2)
* 항상 일관성 있는 데이터 읽기를 보장
* 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 리턴합니다.

### SERIALIZABLE (직렬화 가능, level 3)
* 가장 높은 격리 수준
* 트랜잭션이 완료될 때까지 SELECT하는 모든 데이터에 shared lock이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터 수정 및 입력이 불가능

## AOP
* 공통 관심 사항과 핵심 관심 사항을 분리하는 것입니다.
* 트랜잭션, 시간 측정, 로깅 등
* 스프링에서 프록시 패턴으로 작동합니다.

## Filter, Interceptor
### Filter
* DispatcherServlet 이전에 실행
* init(), doFilter(), destroy()
* 인코딩 변환 처리 등

### Interceptor
* 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전, 후로 실행됨
* 로그인 체크, 권한 체크 등
* preHandler(), postHandler(), afterCompletion()

## DispatcherServlet
* 가장 앞단에서 HTTP 프로토콜로 들어오는 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)라고 정의할 수 있습니다.
* 클라이언트로부터 어떠한 요청이 오면 Tomcat(톰캣)과 같은 서블릿 컨테이너가 요청을 받게 됩니다.
* 그리고 이 모든 요청을 먼저 프론트 컨트롤러인 디스패처 서블릿이 받게 됩니다.

## DispatcherSevlet 흐름
1. DispatcherServlet은 요청을 받고 URL 컨트롤러의 맵핑 작업을 HandlerMapping에 요청
2. HandlerMapping은 URL을 기준으로 어떤 컨트롤러를 사용할지 결정
3. HandlerAdapter는 컨트롤러의 메소드를 호출하는 역할을 하는데 실행될 Interceptor가 있을 때는 Interceptor의 preHandle() 메소드를 실행한 다음 컨트롤러의 메소드를 호출하여 요청
4. 컨트롤러는 요청을 처리한 뒤 처리한 결과 및 ModelAndView를 DispatcherServlet에 전달
5. ViewResolver는 컨트롤러가 처리한 결과를 보여줄 뷰를 결정. ViewResolver는 맵핑되는 View 객체를 DispatcherServlet에 전달
6. DispatcherServlet은 ViewResolver에 전달받은 View Model을 넘겨서 클라이언트에게 보여줄 화면을 생성

## 의존성 주입 방법
### 수정자 주입(Setter)
* 수정자 주입을 사용하면 setter 메소드를 public으로 열어두어야 합니다.
* 즉 언제 어디서든 변경이 가능하다는 뜻입니다.

### 필드 주입
* 코드가 간결하다는 장점이 있지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있습니다.
* DI 프레임워크가 없으면 아무것도 할 수 없습니다.

### 생성자 주입
* 생성자 호출시점에 딱 1번만 호출되는 것이 보장됩니다.
* 생성자 주입을 사용하면 의존성을 주입을 누락하는 것을 방지할 수 있습니다.
  * IDE에서 컴파일 오류로 알려줍니다.
* 생성자를 통해 의존성을 설정하고 변경할 일이 없으므로 final로 안전하게 불변을 보장할 수 있습니다.
* 결국 생성자 주입을 이용하면 원하는 구현체를 주입할 수 있으며, 순수 자바 코드로 테스트를 실행할 수 있습니다.

## Bean Scope
* 싱글톤: 스프링 컨테이너에 한 개의 빈 객체만 존재 - 기본 값
* prototype: 빈을 사용할 때 마다 빈 객체를 생성
* request: HTTP 요청마다 빈 객체를 생성
* session: HTTP 세션마다 빈 객체를 생성

## Spring에서 싱글톤이 좋은 이유
### 웹 애플리케이션에서 싱글톤이 좋은 이유
* 웹 애플리케이션의 특징 중 하나는 여러 종류의 요청을 동시에 처리해야 한다는 것입니다.
* 만약 싱글톤 객체를 쓰지 않는다면 요청마다 요청에 필요한 객체들을 새로 생성해야 할 것이고 이 객체들은 요청이 끝난 후 gc의 대상이 될 것입니다.
* 요청이 많아지면 빈번한 gc로 인해 시스템에 악영향을 끼칠 수 있습니다.

### 싱글톤 패턴 주의점
싱글톤 패턴은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체가 상태를 유지하면 안됩니다.
* 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됩니다.
* 읽기만 가능해야 합니다.
* 클래스 변수가 아닌 지역변수, ThreadLocal 등을 사용해야 합니다.